<HTML>

<HEAD>
<TITLE> ECO32 Instruction Set </TITLE>
</HEAD>

<BODY BGCOLOR="#ffffff" LINK="#008000" ALINK="#008000" VLINK="#fb8000">

<H1> ECO32 Instruction Set </H1>

<TABLE BORDER=1>
<TR><TH> Format </TH><TH> Description                                                    </TH></TR>
<TR><TD> N      </TD><TD> no operands                                                    </TD></TR>
<TR><TD> R      </TD><TD> one register                                                   </TD></TR>
<TR><TD> RH     </TD><TD> one register and the lower 16 bits of a word                   </TD></TR>
<TR><TD> RHh    </TD><TD> one register and the upper 16 bits of a word                   </TD></TR>
<TR><TD> RRH    </TD><TD> two registers and a zero-extended halfword                     </TD></TR>
<TR><TD> RRS    </TD><TD> two registers and a sign-extended halfword                     </TD></TR>
<TR><TD> RRR    </TD><TD> three registers                                                </TD></TR>
<TR><TD> RRX    </TD><TD> three registers, or two registers and a zero-extended halfword </TD></TR>
<TR><TD> RRY    </TD><TD> three registers, or two registers and a sign-extended halfword </TD></TR>
<TR><TD> RRB    </TD><TD> two registers and a sign-extended 16 bit offset                </TD></TR>
<TR><TD> J      </TD><TD> no registers and a sign-extended 26 bit offset                 </TD></TR>
</TABLE>

<BR>

<TABLE BORDER=1>
<TR><TH> Mnemonic </TH><TH> Operands         </TH><TH> Description                                      </TH><TH> Format </TH></TR>
<TR><TD> add      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 + op2                                 </TD><TD> RRY    </TD></TR>
<TR><TD> sub      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 - op2                                 </TD><TD> RRY    </TD></TR>
<TR><TD> mul      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 * op2, signed                         </TD><TD> RRY    </TD></TR>
<TR><TD> mulu     </TD><TD> dst, op1, op2    </TD><TD> dst := op1 * op2, unsigned                       </TD><TD> RRX    </TD></TR>
<TR><TD> div      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 / op2, signed                         </TD><TD> RRY    </TD></TR>
<TR><TD> divu     </TD><TD> dst, op1, op2    </TD><TD> dst := op1 / op2, unsigned                       </TD><TD> RRX    </TD></TR>
<TR><TD> rem      </TD><TD> dst, op1, op2    </TD><TD> dst := remainder of op1/op2, signed              </TD><TD> RRY    </TD></TR>
<TR><TD> remu     </TD><TD> dst, op1, op2    </TD><TD> dst := remainder of op1/op2, unsigned            </TD><TD> RRX    </TD></TR>
<TR><TD> and      </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise AND of op1 and op2                </TD><TD> RRX    </TD></TR>
<TR><TD> or       </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise OR of op1 and op2                 </TD><TD> RRX    </TD></TR>
<TR><TD> xor      </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise XOR of op1 and op2                </TD><TD> RRX    </TD></TR>
<TR><TD> xnor     </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise XNOR of op1 and op2               </TD><TD> RRX    </TD></TR>
<TR><TD> sll      </TD><TD> dst, op1, op2    </TD><TD> dst := shift op1 logically left by op2           </TD><TD> RRX    </TD></TR>
<TR><TD> slr      </TD><TD> dst, op1, op2    </TD><TD> dst := shift op1 logically right by op2          </TD><TD> RRX    </TD></TR>
<TR><TD> sar      </TD><TD> dst, op1, op2    </TD><TD> dst := shift op1 arithmetically right by op2     </TD><TD> RRX    </TD></TR>
<TR><TD> ldhi     </TD><TD> dst, op1         </TD><TD> dst := op1 shifted left by 16 bits               </TD><TD> RHh    </TD></TR>
<TR><TD> beq      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 == op2            </TD><TD> RRB    </TD></TR>
<TR><TD> bne      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 != op2            </TD><TD> RRB    </TD></TR>
<TR><TD> ble      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <= op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bleu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <= op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> blt      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <  op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bltu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <  op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> bge      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >= op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bgeu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >= op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> bgt      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >  op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bgtu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >  op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> j        </TD><TD> offset           </TD><TD> jump to PC+4+offset*4                            </TD><TD> J      </TD></TR>
<TR><TD> jr       </TD><TD> register         </TD><TD> jump to register                                 </TD><TD> R      </TD></TR>
<TR><TD> jal      </TD><TD> offset           </TD><TD> jump to PC+4+offset*4, store PC+4 in $31         </TD><TD> J      </TD></TR>
<TR><TD> jalr     </TD><TD> register         </TD><TD> jump to register, store PC+4 in $31              </TD><TD> R      </TD></TR>
<TR><TD> trap     </TD><TD> -/-              </TD><TD> cause a trap, store PC in $30                    </TD><TD> N      </TD></TR>
<TR><TD> rfx      </TD><TD> -/-              </TD><TD> return from exception, restore PC from $30       </TD><TD> N      </TD></TR>
<TR><TD> ldw      </TD><TD> dst, reg, offset </TD><TD> dst := word @ (reg+offset)                       </TD><TD> RRS    </TD></TR>
<TR><TD> ldh      </TD><TD> dst, reg, offset </TD><TD> dst := sign-extended halfword @ (reg+offset)     </TD><TD> RRS    </TD></TR>
<TR><TD> ldhu     </TD><TD> dst, reg, offset </TD><TD> dst := zero-extended halfword @ (reg+offset)     </TD><TD> RRS    </TD></TR>
<TR><TD> ldb      </TD><TD> dst, reg, offset </TD><TD> dst := sign-extended byte @ (reg+offset)         </TD><TD> RRS    </TD></TR>
<TR><TD> ldbu     </TD><TD> dst, reg, offset </TD><TD> dst := zero-extended byte @ (reg+offset)         </TD><TD> RRS    </TD></TR>
<TR><TD> stw      </TD><TD> src, reg, offset </TD><TD> store src word @ (reg+offset)                    </TD><TD> RRS    </TD></TR>
<TR><TD> sth      </TD><TD> src, reg, offset </TD><TD> store src halfword @ (reg+offset)                </TD><TD> RRS    </TD></TR>
<TR><TD> stb      </TD><TD> src, reg, offset </TD><TD> store src byte @ (reg+offset)                    </TD><TD> RRS    </TD></TR>
<TR><TD> mvfs     </TD><TD> dst, special     </TD><TD> dst := contents of special register              </TD><TD> RH     </TD></TR>
<TR><TD> mvts     </TD><TD> src, special     </TD><TD> contents of special register := src              </TD><TD> RH     </TD></TR>
<TR><TD> tbs      </TD><TD> -/-              </TD><TD> TLB search                                       </TD><TD> N      </TD></TR>
<TR><TD> tbwr     </TD><TD> -/-              </TD><TD> TLB write random                                 </TD><TD> N      </TD></TR>
<TR><TD> tbri     </TD><TD> -/-              </TD><TD> TLB read index                                   </TD><TD> N      </TD></TR>
<TR><TD> tbwi     </TD><TD> -/-              </TD><TD> TLB write index                                  </TD><TD> N      </TD></TR>
</TABLE>

</BODY>
</HTML>
