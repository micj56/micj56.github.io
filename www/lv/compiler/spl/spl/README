
Willkommen beim Projekt SPL!

SPL ("Simple Programming Language") ist mein erster Versuch einer
stark programmierorientierten Einfuehrung in den Compilerbau.

Dem ueblichen Dilemma einer solchen Veranstaltung (viel Stoff, wenig
Zeit und haeufig mangelnde Erfahrung seitens der Studenten in nicht
voellig trivialen Softwareprojekten) wird traditionell mit einer
massiven Beschneidung des Stoffumfangs auf der "hinteren" Seite des
Compilers begegnet. Dann kann man mehr Zeit in z.B. Parsingverfahren,
Grammatiktransformationen und Fehlerbehandlung investieren. Diese
Vorgehensweise bietet aber m.E. ein ziemlich verzerrtes Bild der Arbeit
an einem realen Compiler: in Wirklichkeit greift man (zumindest fuer
die ersten Versionen) weitgehend auf Tools zurueck, immer im Front-End
und ueblicherweise auch beim Codegenerator. Dann aber gewinnt die
Arbeit an Typpruefung, Zwischencodeerzeugung, Baumtransformationen,
Laufzeitorganisation und Registerallokation deutlich mehr Gewicht.

Um trotz der genannten Schwierigkeiten ein halbwegs zutreffendes
Bild vom Compilerbau zu vermitteln, habe ich die kleine Sprache
SPL entworfen, fuer die jeder teilnehmende Student selbstaendig
einen Compiler konstruieren soll, vom Scanner/Parser ueber die
abstrakte Syntax, Typpruefung und Laufzeitorganisation bis hin zur
(einfachen) Registerallokation und Codeerzeugung (Assemblercode
fuer den RISC-Prozessor ECO32, fuer den an unserer Hochschule
bereits ein Simulator zur Verfuegung steht). Dabei werden die
wichtigsten Schnittstellen von mir vorgegeben; das erleichert
die Arbeit fuer die in nichttrivialen Projekten unerfahrenen
Studenten erheblich. Ebenso werden einige Module vorgegeben,
deren Funktionalitaet zwar notwendig fuer einen einsatzfaehigen
Compiler ist, deren Konstruktion aber mehr in den Bereich
Datenstrukturen faellt (z.B. Konstruktoren fuer die Knoten der
abstrakten Syntax, Hashtabelle fuer Symbole, Organisation der
Symboltabellen).

Zum zeitlichen Umfang: Uns stehen etwa 13 Wochen zur Verfuegung,
mit 2 Stunden Vorlesung und 2 Stunden Uebung/Praktikum pro Woche.
Ich werde in der Vorlesung die mehr theoretischen Gesichtspunkte
besprechen; das Praktikum muss zur Diskussion des praktischen
Herangehens und der Fragen von Studenten zur Verfuegung stehen.
Das wiederum setzt einen erheblichen Zeiteinsatz seitens der
Studenten ausserhalb der Veranstaltung voraus. Diese Tatsache
muss bereits zu Beginn des Semesters deutlich vermittelt werden.

Hier ist ein vorlaeufiger Plan des zeitlichen Ablaufs:

 1. Ueberblick, Phasen, Interfaces, Spracheigenschaften
 2. Regulaere Sprachen & Ausdruecke, Endliche Automaten
    [Warmlauf-Aufgabe fertig]
 3. NEAs, DEAs, Teilmengenkonstruktion, Lex/Flex
 4. Kontextfreie Sprachen & Grammatiken, Ableitungen
    [Scanner fertig]
 5. LL-Parser, First- und Follow-Mengen, Recursive Descent Parser
 6. LR-Parser, Parse-Tabellen, S/R- und R/R-Konflikte, Yacc/Bison
 7. Abstrakte Syntax
    [Parser fertig]
 8. Synthetisierte und vererbte Attribute, Typen und Typkonstruktoren
    [Abgabe der ersten Hausuebung:
     Scanner, Parser, Abstrakte Syntax]
 9. Darstellung von Typen, Symboltabelle, Typechecker
10. Laufzeitorganisation, Stack und Heap
    [Typechecker fertig]
11. Codegeneratoren, Codegenerator-Generatoren
    [Stackframes & Registervergabe fertig]
12. Registerallokation durch Anfaerben von Graphen
    [Abgabe der zweiten Hausuebung:
     Typechecker, Stackframes & Registervergabe, Codegenerator]
13. Optimierende Compiler

Ein gewisses Problem bei stark programmierlastigen Faechern ist die
nicht unerhebliche Versuchung fuer Studenten, durch Kopieren der
Loesungen von Kommilitonen den eigenen Zeitaufwand zu reduzieren.
Das muss mit Hinweis auf die Folgen von Betrug (Ausschluss von der
Klausur) strikt unterbunden werden; geplant ist der Einsatz eines
Tools zur Aehnlichkeitsmessung von Software (MOSS), das an anderen
Hochschulen (namentlich Berkeley) bereits erfolgreich benutzt wird.

Fuer Anregungen, Kritik, Fragen und Verbesserungsvorschlaege
bin ich jederzeit dankbar. Bitte schreiben Sie an

  Hellwig.Geisse@mni.fh-giessen.de

Viel Spass!
Hellwig Geisse

