\documentclass[utf8,9pt]{beamer}
%\documentclass[utf8,handout]{beamer}
\usepackage{pgfpages}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{pgfpages}
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{keyval}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{array}
%\usepackage{eulervm}
%\geometry{paperwidth=120mm,paperheight=80mm}
\include{beamer}
%\usepackage{lmodern}

\mode<handout>{
  \pgfpagesuselayout{2 on 1}[a4paper,border shrink=2mm]
% \pgfpagesuselayout{4 on 1}[a4paper,border shrink=2mm,landscape]
}

\frenchspacing

\title{Betriebssysteme: Einführung in die Rechnerarchitektur}
\subtitle{WS 2016/17}
\author{Michael Jäger}

%\institute[ISA -- Institut für Systemarchitektur]{Institut für Systemarchitektur\\ FB MNI}
\date{\today}
%\logo{\pgfimage[width=14mm,height=1cm]{fhlogo.jpg}}
\titlegraphic{\includegraphics[width=3cm]{/home/jaeger/lib/vorlagen/logos/thm/THM_Logo_4c}}

\subject{Rechnerarchitektur}


\input{localdefs}


\begin{document}


\frame{\titlepage}


\part{Einführung}



%\frame{
%\frametitle{Inhalt}
%\tiny\begin{columns}
%\column{0.5\textwidth}
%\tableofcontents[subsections numbered,part=1]
%\tableofcontents[subsections numbered,part=2]
%\column{0.5\textwidth}

%\tableofcontents[subsections numbered,part=3]
%\tableofcontents[subsections numbered,part=4]
%\end{columns}
%}


\begin{frame}{Von-Neumann-Architektur}{(Speicherprogrammierter Rechner)}
\begin{columns}
\column[T]{0.5\textwidth}
\begin{block}{John von Neumann}
\tiny\fontsize{8pt}{8pt}\selectfont

\begin{itemize}
\item Ungarischer Mathematiker, 1903-1957
\item Begründer der modernen Spieltheorie
\item Pionier der Monte-Carlo-Simulation
\item Mitentwickler der Wasserstoffbombe
\item Mitbegründer der modernen Rechnerarchitektur
\end{itemize}
 \vspace*{-5mm} 
   \cbild[0.3\textwidth]{bilder/JohnvonNeumann-LosAlamos}
\end{block}

\column[T]{0.5\textwidth}
\vspace*{3mm} 
\centering{Architekturmodell des speicherprogrammierten Rechners}

\vspace*{3mm}
\hspace*{-4mm}
\bild[1.35\textwidth]{bilder/vonNeumannArchitektur}
 \end{columns}
\end{frame}






\begin{frame}{Bussysteme}{}
\begin{block}{Bus}
\begin{itemize}
\item mehrere parallele Leitungen ("`Busbreite"' = Anzahl der Leitungen)
\item mehrere Funktionseinheiten angeschlossen
\item Informationsaustausch zeitmultiplex: Zu jedem Zeitpunkt sind immer nur zwei Einheiten (Sender, Empfänger) miteinander verbunden.
\item unidirektional oder  bidirektional
\end{itemize}
\end{block}
\begin{block}{Interne und externe Busse}
Unterschiedliche Busse sind hierarchisch miteinander verknüpft
\begin{itemize}
\item CPU-internes Bussystem verbindet CPU-Komponenten
\item Systembus verbindet CPU, Hauptspeicher und E/A-Komponenten
\item weitere Busse zum Anschluss jeweils mehrerer Bus-kompatibler Geräte,
  z.B. USB (Universal Serial Bus), PCI (Peripheral Component Interconnect)
\end{itemize}
\end{block}
\end{frame}






\begin{frame}{}{}
\begin{block}{Bustypen}
\begin{itemize}
\item Adress-Bus (A-Bus)
   \begin{itemize}
   \item unidirektional
   \item zur Auswahl von Speicherzellen, Bausteinen, E/A-Registern
   \end{itemize}
\item Daten-Bus (D-Bus)
   \begin{itemize}
   \item bidirektional
   \item  8-64 Leitungen
   \item zum Datentransport zwischen Bausteinen
   \end{itemize}
\item Steuer-Bus (Control-Bus, S-Bus)
   \begin{itemize}
   \item Unterschiedliche Übertragungsrichtungen, jede Leitung für sich unidirektional
   \item typisch:  4-20 Leitungen
   \item zur Steuerung der Zusammenarbeit der einzelnen Baugruppen
   \end{itemize}
\end{itemize}
\end{block}
\end{frame}







\begin{frame}{Bus-Treiber}

\begin{block}{Problem bei Bus-Systemen}
Zu jedem Zeitpunkt darf immer nur ein einziger Sender am Bus aktiviert sein
\end{block}

\begin{block}{Aufgaben des Bus-Treibers}
\begin{itemize}
\item An- und Abschalten der angeschlossenen Bausteine
\item Durchschalten der gewünschten Übertragungsrichtung bei bidirektionalen Busanschlüssen
\item Ziel: Hohe Anschlußkapazität ("`Fan-Out"')
\end{itemize}
\end{block}
\end{frame}



\begin{frame}{ALU -- Arithmetisch-logische Einheit}{}
\begin{block}{Typische Merkmale}
\begin{itemize}
\item Operationen:
  \begin{itemize}
  \item Binäre Ganzzahl-Arithmethik
  \item Logische Operationen (UND, ODER, NOT, XOR)
  \item Verschiebeoperationen (arithmetisch, logisch)
  \end{itemize}
\item Zwei Eingabebusse für Operanden
\item Ein-/Ausgabebus für Ergebnis
\item Steuereingang vom Leitwerk
\item Statusausgang
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Sonstige Recheneinheiten}
\begin{block}{}
Moderne Prozessoren haben oft neben der ALU weitere "`Recheneinheiten"' 
für spezielle Zwecke, z.B.
\begin{itemize}
\item Grafikberechnungen
\item Gleitkomma-Arithmetik
\item Kryptographische Berechnungen
\item Hauptspeichermanagement
  \begin{itemize}
  \item  MMU -- Memory Management Unit)
  \item Cache/Snoop - Unit
  \end{itemize}

\end{itemize}

\end{block}

\end{frame}



\begin{frame}{Maschinenbefehle}{}

\begin{block}{}
\begin{itemize}
\item Compiler erzeugt Maschinenbefehle aus den Anweisungen
   einer höheren Programmiersprache
\item Ausführung:
   \begin{itemize}
   \item Maschinenbefehle des Programms im Hauptspeicher
   \item Prozessor kopiert jeweils einen Befehl in das Befehlsregister
   \item Prozessor dekodiert den Befehl und führt ihn aus
   \end{itemize}
\item Befehls-Bestandteile:
  \begin{itemize}
  \item Operationscode ("`OpCode"') identifiziert den Maschinenbefehl
  \item Operanden -- abhängig von Befehl

    Beispiele: Registernummern, Speicheradressen, Direktoperanden
  \end{itemize}
\item Verschiedene Befehlsformate
\item Befehle ggf. unterschiedlich lang
\end{itemize}
\end{block}
\end{frame}




\begin{frame}{Befehlstypen}{}

\begin{block}{}
\begin{itemize}
\item Transferbefehle

 Kopieren von Daten aus Speicherzellen oder Register in andere Speicherzellen oder Register
\item  Flagbefehle

 Manipulation der Flags im Statusregister, z.B. Carry-/Interrupt\\
 Vorbelegungen für Addition/Subtraktion\\
 Programmteile vor Unterbrechungen schützen
\item Arithmetische/logische Instruktionen

Addition, Subtraktion, Multiplikation und Division\\
AND, OR und XOR \\
\item Rotations- und Shiftbefehle
\item  Kontrollflussbefehle

 unbedingten Sprungbefehle, bedingte Branchbefehle (Verzweigungen),
Unterprogrammaufruf, Rücksprunginstruktionen
\item  Weitere Befehle

 NOP, STOP
\end{itemize}
\end{block}
\end{frame}




\begin{frame}{Mikroprogrammierung}{}

\begin{block}{}
\begin{itemize}
\item Maschinenbefehle müssen nicht immer in Hardware realisiert sein
\item Mikroprogrammierung:
  \begin{itemize}
  \item Ein komplexer Maschinenbefehl wird als
       Sequenz primitiver Maschinenbefehle ("`Mikroprogramm"') implementiert
  \item Mikroprogramme sind im Prozessor gespeichert
  \item Ausführung des komplexen Befehls durch Abarbeitung des Mikroprogramms
  \end{itemize}
\end{itemize}
\end{block}

\end{frame}





\begin{frame}{Ablauf der Befehlsausführung}{}
\begin{columns}
\column{0.5\textwidth}
   \cbild[\textwidth]{bilder/ablauf1.png}
\column{0.5\textwidth}
   \vspace*{-10mm}
   \cbild[\textwidth]{bilder/befehlsablauf.png}
\end{columns}
\end{frame}







\begin{frame}{Typischer Ablauf der Befehlsausführung}{}

\begin{block}{\small FETCH-Phase}
\begin{Itemize}
\item Befehl, auf den der Programmzähler verweist, aus dem Hauptspeicher
   in das Befehlsregister kopieren 
 \end{Itemize}
\end{block}

\begin{block}{\small DECODE-Phase}
\begin{Itemize}
\item Befehl dekodieren, Opcode und Operanden validieren,
   bei illegalem Befehl: Ausnahmenzustand
\item Programmzähler erhöhen
\end{Itemize}
\end{block}
\begin{block}{\small FETCH-OPERANDS-Phase}
 bei lesenden Hauptspeicherzugriffen
\begin{itemize}
  \item Adressen der Speicheroperanden berechnen
  \item Speicher-Operanden in den Prozessor laden
\end{itemize} 
\end{block}
\end{frame}


\begin{frame}{}{}

\begin{block}{\small EXECUTE-Phase}
\begin{itemize}
\item Befehl ausführen (Ausführung einer Rechenoperation durch ALU)
\item Ggf. Ausnahmebehandlung (Division durch 0, Überlauf, \dots)
\item Ergebnis in das Zielregister speichern
\item Bei Sprungbefehl Programmzähler aktualisieren
\end{itemize}
\end{block}
\begin{block}{\small WRITEBACK-Phase}
bei schreibenden Hauptspeicherzugriffen
  \begin{itemize} 
  \item Adressen der Speicheroperanden berechnen
  \item Wert in den Hauptspeicher kopieren
  \end{itemize}
\end{block}
\end{frame}















\begin{frame}{Zahlen zum technischen Fortschritt}{}

\begin{block}{Anzahl der Transistoren}
\begin{tabular}{lr}
 Intel 8080 Mikroprozessor &    4 500 \\
 Intel 80286 Mikroprozessor &  134 000 \\
 Intel 80386 Mikroprozessor &  275 000 \\
 Intel Pentium Mikroprozessor &        3 100 000 \\
 Intel Pentium 4 Mikroprozessor &      42 000 000 \\
 AMD KG (Athlon 64) Mikroprozessor &   105 900 000 \\
 Intel Core i7 Mikroprozessor &        731 000 000 \\
 Eight Core Xeon Nehalem-EX Mikroprozessor &           2 300 000 000 \\
 RV820 ATI/AMD Grafikprozessor &       2 154 000 000 \\
 NVIDIA GTX Titan X Grafikprozessor &        8 000 000 000 \\
\end{tabular}
\end{block}
\end{frame}



\begin{frame}{Zahlen zum technischen Fortschritt}{}

\begin{block}{Festplattenkosten pro Gigabyte (in US-Dollar)}
\begin{tabular}{lr}

 1990  &   53 000\\
 1995  &   850\\
 2000  &   20\\
 2005  &   1\\
 2010  &   0.10\\
 2015  &   0.04\\
\end{tabular}
\end{block}

\begin{block}{RAM-Kosten pro Gigabyte (in US-Dollar)}
\begin{tabular}{lr}

 1990 &   120 000\\
 1995 &   33 000\\
 2000 &   1 400\\
 2005 &   190\\
 2010 &   20\\
 2015 &   10\\
\end{tabular}
\end{block}
\end{frame}




\begin{frame}{Von-Neumann-Rechner}{}
   \cbild[0.6\textwidth]{bilder/cpu.png}
\end{frame}

\begin{frame}{Harvard-Architektur}{}
   \cbild[\textwidth]{bilder/harvard.png}
\end{frame}

\begin{frame}{PC-Architektur mit externem Speichercontroller}{}
   \cbild[0.40\textwidth]{bilder/pc-motherboard}
\end{frame}

\begin{frame}{Cache}{}
\begin{block}{Begriffsdefinition}
Ein Cache ist ein schnell zugreifbarer Speicher, in dem Kopien von Daten
aus einem langsameren größeren Speicher gehalten werden. Wenn häufig benötigte
Daten im Cache stehen, kann die Zugriffsgeschwindigkeit gesteigert werden.  
\end{block}

\begin{block}{Anwendungsbeispiele}

\begin{itemize}
\item Ein Prozessor lädt vom Hauptspeicher gleich mehrere hintereinender
   gespeicherte Befehle in den Befehlscache (PREFETCH). Wenn keine Sprungbefehle dabei
   sind, spart man FETCH-Operationen.
\item Ein Prozessor speichert die zuletzt zugegriffenen Daten in einem
   Datencache. Eine Geschwindigkeitssteigerung ergibt sich, wenn Daten mehrfach zugegriffen werden.
\end{itemize}
\end{block}


\begin{block}{Performance}
\begin{itemize} 
\item 
Die Trefferrate ("`hit rate"') gibt an zu welchem Prozentsatz Datenzugriffe aus dem Cache  befriedigt werden können. 
\item Ein Lesezugriff auf nicht im Cache stehende Daten ("`read miss"')
   verzögert die Ausführung. Ein entsprechender Schreibzugriff   ("`write miss"')
   führt nicht unbedingt zu einer Verzögerung.
 \end{itemize}
\end{block}

\end{frame}




\begin{frame}{}{}
\begin{block}{Cache-Einträge}
bestehen aus
\begin{itemize}
\item Datenblock: Kopie der Daten/Befehle, z.B. 64 Byte große "`cache lines"'
\item Etikett ("`tag"'): Anfangsadresse der Originaldaten im Hauptspeicher
\item Flags: verschiedene Bits zur Steuerung der Auslagerungs- und Schreibstrategien.
Bsp: Ein "`valid"'-Bit ist gesetzt, wenn der Cacheblock gültige Daten
enthält.  Bei "`write back"'-Caches gibt es ein "`dirty"'-Bit, das bei Modifikation gesetzt wird
\end{itemize}

\end{block}


\begin{block}{Auslagerungsstrategie}
\begin{itemize}
\item Wird bei vollem Cache ein weiterer Cache-Platz benötigt, muss ein anderer
Platz freigeräumt werden. 
\item Häufig wird der Platz, der am längsten nicht
mehr zugegriffen wurde, freigeräumt (LRU-Strategie, "`least recently used"').
\end{itemize}
\end{block}
\end{frame}




\begin{frame}{}{}
\begin{block}{Cache-Hierarchie}
Oft sind mehrere Caches in einer Hierarchie angeordnet, z.B.
\begin{itemize}
\item Level 1: kleiner, schneller Cache für Daten und Befehle nahe beim
   Prozessor(-Kern). Größenbeispiel:  64Kb
\item   Level 2: großer Cache für Daten, um Hauptspeicherzugriffe einzusparen.
  Größenbeispiel:  1Mb
\item Level 3: Cache, der von mehreren Prozessorkernen gemeinsam
   benutzt wird. Ein Ziel ist dabei der schnelle Datenaustausch zwischen
   den Prozessorkernen über den Cache.  
\end{itemize}
\end{block}


\begin{block}{Schreibstrategie}
\begin{itemize}
\item Ein "`write through"'-Cache synchronisiert bei jeder Modifikation
   den Inhalt sofort mit dem Hauptspeicher
\item  Ein "`write back"'-Cache verzögert das Zurückschreiben modifizierter
Daten.
Wird ein modifizierter Platz freigeräumt ("`dirty bit"' gesetzt), muss dessen Inhalt
zunächst in den Hauptspeicher zurück geschrieben werden. Dies kann sowohl
beim Lesen als auch beim Schreiben von noch nicht im Cache vorhandenen
Daten passieren.  
\item Mischstrategien verzögern das Durchschreiben so lange, bis mehrere
Cache-Lines zurückgeschrieben werden müssen. Dadurch spart man Busanforderungen.
\end{itemize}

\end{block}

\end{frame}

\end{document}
