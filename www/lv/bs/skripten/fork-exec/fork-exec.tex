\documentclass[utf8,9pt]{beamer}
%\documentclass[utf8,handout]{beamer}
\usepackage{pgfpages}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{pgfpages}
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{keyval}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{array}

\include{beamer}


\mode<handout>{
  \pgfpagesuselayout{2 on 1}[a4paper,border shrink=2mm]
% \pgfpagesuselayout{4 on 1}[a4paper,border shrink=2mm,landscape]
}

\frenchspacing

\title{Betriebssysteme: UNIX-Operationen zur Prozesskontrolle}
\subtitle{WS 2016/17}
%\author{Michael Jäger}

\date{\today}
\titlegraphic{\includegraphics[width=3cm]{bilder/THM_Logo_4c}}

\subject{Wichtige Prozessoperationen in UNIX}


%\input{localdefs}
\newcommand{\bild}[2][0.9\textwidth]{\includegraphics[width=#1]{#2}}

% fest verankertes Bild, zentriert
\newcommand{\cbild}[2][0.9\textwidth]{\vspace*{5mm}\begin{center}\bild[#1]{#2}\end{center}\vspace{5mm}}
\newcommand{\blau}[1]{\textcolor{blue}{#1}}
\newcommand{\rot}[1]{\textcolor{red}{#1}}
\newcommand{\tblau}{\color{blue}}
\newcommand{\trot}{\color{red}}

\newenvironment{blue}{\color{blue}}{}
\newenvironment{red}{\color{red}}{}

\begin{document}


\frame{\titlepage}


\part{Einführung}



\begin{frame}{Prozesse und Programme}

  \begin{block}{Programm}
    \tiny\fontsize{8pt}{8pt}\selectfont

    \begin{itemize}
    \item Verschiedene Repräsentationen
      \begin{itemize}
      \item Quelltext: Dateien auf Datenträgern
      \item Maschinenprogramm: Datei auf Datenträger
      \item Prozess: Hauptspeicher
      \end{itemize}
    \end{itemize}
  \end{block}

  \begin{block}{Prozess: Programm in Ausführung}
    \tiny\fontsize{8pt}{8pt}\selectfont

    \begin{itemize}
    \item  Programmspeicher (auch "`Adressraum"', "`Prozess-Image"'),\\
      in Segmente unterteilt: Code, statische Daten, Heap, Stack
    \item Deskriptor (Metadaten des Prozesses), Element der
      Prozesstabelle
      \begin{itemize}
      \item Identifikationsnummer
      \item Deskriptor der offenen Dateien
      \item Deskriptor für Programmspeicher-Segmente
      \item User-ID
      \item Priorität
      \item Prozessorzustand
      \item \dots
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}






\begin{frame}{Prozesserzeugung}{}
  \begin{block}{"`Normale"' Prozesserzeugung: Untrennbar gekoppelt an
      Programmaufruf}
    \begin{itemize}
    \item Programm wird aufgerufen (interaktiv oder durch anderes
      Programm)
      \begin{itemize}
      \item Prozessdeskriptor initialisieren
      \item Programmspeicher reservieren
      \item Programm laden (Programmspeicher initialisieren)
      \item Warten auf Prozessorzuteilung
      \end{itemize}
    \end{itemize}
  \end{block}

  \begin{block}{UNIX: Trennung von Programmaufruf und
      Prozesserzeugung}
    \begin{itemize}
    \item {\em exec\/}: Systemkern "`tauscht den Programmspeicher des
      Prozesses aus"'
    \item {\em fork\/}: Systemkern kopiert vorhandenen Prozess
    \end{itemize}
  \end{block}
\end{frame}









\begin{frame}[fragile]{}{}
  \begin{block}{Windows-Beispiel: CreateProcess (Programm in neuem
      Prozess starten) }
      \tiny\fontsize{6pt}{6pt}\selectfont
\begin{verbatim}
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

void _tmain( int argc, TCHAR *argv[] )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ...

    if( !CreateProcess( NULL,   // No module name (use command line)
        argv[1],        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi )           // Pointer to PROCESS_INFORMATION structure
    ) {
        printf( "CreateProcess failed (%d).\n", GetLastError() );
        return;
    }

    // Wait until child process exits.
    WaitForSingleObject( pi.hProcess, INFINITE );

    // Close process and thread handles. 
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
}
\end{verbatim}
  \end{block}
\end{frame}




\begin{frame}{UNIX "`fork"': Systemkern kopiert aufrufenden Prozess}{}

  \bild[0.8\textwidth]{bilder/fork01.pdf}
\end{frame}






\begin{frame}{fork: Kopieren des Programmspeichers}{}

  \begin{block}{Separater Programmspeicher pro Prozess}
    \begin{itemize}
    \item Kind hat eigenen, separaten Programmspeicher
    \item Speicher direkt nach dem fork absolut identisch
    \item Kind kann seinen Speicher danach unabhängig vom
      Elternprozess ändern
    \end{itemize}
  \end{block}

  \begin{block}{Effiziente Implementierung}
    \begin{itemize}
    \item Prinzip: Zwei logisch verschiedene Speicherbereiche mit
      gleichem Inhalt werden durch einen gemeinsam genutzten
      physikalischen Speicherbereich implementiert.
    \item Beispiel: Das Maschinecode-Segment wird gemeinsam benutzt
    \item "`Copy-On-Write"': Zunächst alles gemeinsam nutzen, erst bei
      Änderungen kopieren
    \item Details dazu später im Themenbereich "`Speicherverwaltung"'
    \end{itemize}

  \end{block}
\end{frame}



\begin{frame}{fork: Initialisierung des Prozessdeskriptors}{}

  \begin{block}{Vom Elternprozess vererbte Attribute}
    \begin{itemize}
    \item Deskriptoren für offene Dateien und Kommunikationsendpunkte
      (sockets, pipes)
    \item Benutzer
    \item aktuelles Verzeichnis
    \item Priorität ("`nice"'-Wert)
    \item Prozessorzustand (leicht modifiziert)
    \item \dots
    \end{itemize}
  \end{block}

  \begin{block}{Nicht vererbte Attribute}
    \begin{itemize}
    \item Prozess-Identifikationsnummer (PID) wird neu vergeben
    \item PID des Elternprozesses
    \item Erzeugungszeit
    \item verbrauchte CPU-Zeit
    \item \dots
    \end{itemize}
  \end{block}
\end{frame}





\begin{frame}{fork: Prozessorzustandsdeskriptor}{}

  \begin{block}{\small Nutzungsprinzip}
    \footnotesize
    \begin{itemize}
    \item Systemkern kann einem laufenden Prozess den Prozessor temporär
      "`wegnehmen"'
    \item Die für die spätere Fortsetzung relevanten Registerinhalte werden "`gerettet"' 
    \item Retten: Kopieren in den Prozessdeskriptor als
         "`Prozessorzustands-Deskriptor"' (PZD)
    \end{itemize}
  \end{block}

  \begin{block}{\small Bestandteile des PZD}
   \footnotesize
    \begin{itemize}
    \item Programmzähler ("`program counter"', PC)
    \item Befehlsregister, Statusregister
    \item Mehrzweckregister
    \item \dots
    \end{itemize}
  \end{block}

  \begin{block}{\small Der PZD des Kindprozesses}
    \footnotesize
    \begin{itemize}
    \item Der PZD des Elternprozesses wird (fast) kopiert
    \item Speziell: PC wird vererbt, Kindprozess ist an der gleichen
      Stelle (Rückkehr aus {\em fork\/})
    \item \blau{Nicht vererbt: Das Returnwert-Register enthält beim Kind Null,
        beim Elternprozess die Kind-PID}
    \end{itemize}

  \end{block}

\end{frame}



\begin{frame}[fragile]{fork: Programmbeispiel}{}

\footnotesize
  \vspace*{-1em}
\begin{verbatim}
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  pid_t kind_pid;  // ueblicherweise: pid_t = "unsigned long"
  pid_t meine_pid;

  printf("vor fork, PID=%d\n", meine_pid=getpid());
  kind_pid=fork();
\end{verbatim}

  \vspace*{-12pt}
  \begin{blue}
    \footnotesize
    \begin{verbatim}  
  // Ab hier sind zwei Prozesse im Spiel!
    \end{verbatim}
  \end{blue}

  \vspace*{-22pt}
    \footnotesize
\begin{verbatim}
  switch (kind_pid) {
    case -1: perror("fork-Fehler");
             exit(1);
    case  0: printf("Kind: PID=%d\n", meine_pid=getpid());
             printf("Kind: Eltern-PID=%d\n", getppid());
             break;
    default: ("Elternprozess: nach fork, Kind-PID=%d\n", kind_pid);
  }

  printf("Ende: PID=\d\n", meine_pid);
  exit(0);
}
\end{verbatim}

\begin{blue}
  \small Welche Ausgabe erzeugt dieses Programm, falls Eltern-PID=10
  und Kind-PID=11?
\end{blue}

\end{frame}




\begin{frame}[fragile]{Fehlschlag von fork}{}

\begin{block}{Mögliche Gründe für fork-Fehler}
\begin{itemize}
\item Limit für die Anzahl der Prozesse eines Benutzer erreicht
\item Ungenügend Speicherplatz für den Programmspeicher
\item Ungenügend Speicherplatz für den neuen Deskriptor
\end{itemize}
\end{block}

\begin{block}{Fehlerbehandlung im Programm}
\begin{itemize}
\item {\em fork\/}-Rückgabewert bei Fehlschlag: -1
\item globale Variable {\em errno\/} ({\tt errno.h}) enthält Fehlercode, z.B.
   {\tt ENOMEM} 
\item Funktion {\em perror\/} gibt Fehlertext zum Fehlercode aus, z.B.\\
  fork-Fehler: cannot allocate memory
\end{itemize}

    \footnotesize
\begin{verbatim}
       switch (kind_pid = fork()) {
         case -1: perror("fork-Fehler");
                  exit(1);
         ...
\end{verbatim}

\begin{blue}
Mit {\tt exit(1)} terminiert der aktuelle Prozess. Der Parameter 1 wird dem Elternprozess zur
Verfügung gestellt und signalisiert  einen fatalen Fehler.
\end{blue}

\end{block}

\end{frame}






\begin{frame}{exec}{Programmaufruf}

  \begin{block}{Funktionsweise}
    \begin{itemize}
    \item Einem Prozess können {\bf nacheinander} unterschiedliche Programme
      zugeordnet sein
    \item {\em exec\/} ersetzt das aufrufende Programm durch ein
      anderes Programm
    \item neues Programm wird ab dem ersten Befehl ausgeführt
    \item kein Rücksprung in das ursprüngliche Programm
    \item Dateien bleiben offen
    \end{itemize}
  \end{block}

\begin{block}{Parameter}
\begin{itemize}
\item Dateipfad des aufzurufenden Programms
\item Liste der an das Programm zu übergebenden Parameter (beliebige Zeichenketten)
\item Liste der Umgebungsvariablen ("`Environment"')
\end{itemize}
\end{block}

\end{frame}





\begin{frame}{exec: Programmaufruf (kein neuer Prozess!)}{}

 \bild[0.7\textwidth]{bilder/exec01.pdf}

\end{frame}




\begin{frame}[fragile]{Die exec-Familie}{}

  \begin{block}{\small exec-Varianten}
    \footnotesize
\begin{verbatim}
   #include <unistd.h>

   extern char **environ;

   int execl( const char *path, const char *arg, ...);
   int execlp( const char *file, const char *arg, ...);
   int execle( const char *path,
               const char *arg , ...,  char* const envp[]);
   int execv( const char *path, char *const argv[]);
   int execvp( const char *file, char *const argv[]);
   int system(const char *command); (ANSI)
\end{verbatim}
  \end{block}

\vspace*{2em}

\small
Die Buchstaben hinter {\em exec\/}:
\begin{itemize}
\item l - Listenformat für Parameter
\item v - Vektorformat für Parameter
\item p - Pfadsuche gemäß PATH
\item e - Umgebungsvariablen (Environment) werden explizit angegeben 
\end{itemize}
\end{frame}





\begin{frame}[fragile]{{\em execl\/} vs. {\em execv\/}}{}
  \begin{block}{\small Argumentliste (l) versus Argumentvektor (v)}
    \footnotesize
    \begin{itemize}
    \item Bei {\em execl\/} wird jedes an das Programm zu übergebende
      Argument einzeln übergeben, ein NULL-String terminiert die
      variabel lange Liste
\begin{verbatim}
   execl("/usr/bin/ls", "ls", "-l", "/tmp", NULL)
\end{verbatim}
    \item Bei {\em execv\/} wird ein Array
      übergeben, die {\tt char*}-Elemente sind die an das Programm zu übergebenden
      Zeichenketten
\begin{verbatim}
   char* argumentvektor[] = {"ls", "-l", "/tmp", NULL};
   execv("/usr/bin/ls", argumentvektor)
\end{verbatim}
 
    \end{itemize}

  \end{block}
\end{frame}



\begin{frame}[fragile]{{\em exec\/} mit oder ohne "`p"'}{}

\begin{block}{PATH: Liste von Verzeichnissen mit Programmen}
\begin{itemize}
\item Bei Standardprogrammen entscheidet der Administrator über den Speicherort.
   Hart-kodierte Pfade in Programmen sind daher ungeeignet.
\item Umgebungsvariable PATH enthält die Liste der Programm-Verzeichnisse, z.B.
\begin{verbatim}
PATH=/opt/sbin:/usr/local/bin:/usr/bin:/bin
\end{verbatim} 
\item Keine automatische Suche im aktuellen Verzeichnis\\
   (Was macht folgendes Shell-Kommando? {\tt PATH=\$PATH:.} )
\item Die PATH-Variable wird von {\em execvp\/} und {\em execlp\/} benutzt
\item Die anderen {\em exec\/}-Varianten erwarten einen vollständigen Pfad
\item Auch ein relativer Pfad ist ein vollständiger Pfad, z.B. \verb#"./testprog"# ) 
\end{itemize}
\end{block}
\end{frame}







\begin{frame}[fragile]{{\em exec\/}-Funktionen mit "`e"' am Ende}{}
\begin{block}{Umgebungsvariablen}
\begin{itemize}
\item Umgebungsvariablen sind neben Parametern eine weitere Möglichkeit,
   das Programmverhalten zu konfigurieren
\item Der Zugriff erfolgt in C
  \begin{itemize}
  \item mit getenv:  \verb#getenv("HOME")#
  \item oder über den 3. {\em main\/}-Parameter:
   \begin{verbatim}
   int main(int agumentanzahl, 
            const char *argumentvektor[], 
            const char *umgebungsvariablen[])
   \end{verbatim}

  \end{itemize}
 
\item Mit {\em execle\/} und {\em execvpe\/} kann man dem neuen Programm
   eine beliebige Liste von Umgebungsvariablen übergeben
\item Bei den anderen exec-Varianten erhält
   das  neue Programm eine Kopie der aktuellen Umgebungsvariablen 
\end{itemize}

\end{block}

\end{frame}





\begin{frame}[fragile]{Mögliche Fehler beim Programmaufruf?}{}


\begin{itemize}[<+(1)->]

\item E2BIG  \pause -- Argumentliste zu groß
\item EACCESS  \pause -- Zugriffsrecht "`ausfühbar"' fehlt
\item ENOMEM \pause -- Hauptspeichrmangel
\item ENOENT \pause -- Datei nicht gefunden (NO directory ENTry)
\end{itemize}

\end{frame}



\begin{frame}[fragile]{{\em fork\/} und {\em exec\/} kombinieren}{}

\begin{block}{In fast allen Anwendungsfällen werden {\em fork\/} und {\em exec\/}
kombiniert}
\begin{itemize}
\item Elternprozess erzeugt Kindprozess
\item Kindprozess führt neues Programm aus
\item Elternprozess setzt die Ausführung des aktuellen Programms fort
\end{itemize}
\end{block}


\begin{block}{Kombinationsschema}
{
\footnotesize
\begin{verbatim}
  switch (pid = fork()){
  case -1: ...
  case  0:
           // Kind ruft anderes Programm auf
           execvp( ... );
           // exec gescheitert
           perror("exec error");
           exit(1);
  }

  // Elternprozess macht weiter
  ...
\end{verbatim}
}
\begin{blue}
Was passiert, wenn man das exit(1) vergisst?
\end{blue}

\end{block}
\end{frame}




\begin{frame}{{\em fork\/} und {\em exec\/} kombinieren}{}

 \bild[0.6\textwidth]{bilder/fork-exec.pdf}

\end{frame}





\begin{frame}{Prozessterminierung}{}

  \begin{block}{\small Prozess terminiert sich selbst}
    \begin{itemize}
    \footnotesize
    \item Prozess kann sich selbst terminieren:
      {\em  exit(Exitcode) \/}\\
      exit-Code: 0 - Erfolg, 1 - fataler Fehler
    \item Systemkern gibt Ressourcen frei:
      \begin{itemize}
    \footnotesize
      \item Programmspeicher
      \item Deskriptoren für Dateizugriffe und Kommunikationsendpunkte
      \item Prozessorzustands-Deskriptor
      \item \dots
      \end{itemize}
    \item Prozessdeskriptor bleibt erhalten ("`Zombie"'),\\
      enthält:
      \begin{itemize}
    \footnotesize
      \item exit-Code
      \item Ressourcenverbrauchswerte (z.B. verbrauchte CPU-Zeit,
        gesamte Laufzeit)
      \end{itemize}
    \end{itemize}
  \end{block}

  \begin{block}{\small Prozess wird durch Signal terminiert}
    \begin{itemize}
      \footnotesize
    \item Ein besonderes Ereignis tritt ein (z.B. Benutzer betätigt
      STRG-C-Taste)
    \item Systemkern erzeugt ein Signal für einen Empfängerprozess
    \item Empfängerprozess wird durch Signal terminiert (andere
      Signalbehandlung möglich)
    \item Prozessdeskriptor enthält Details zum Ereignis
    \item ansonsten wie bei {\em exit\/}
    \end{itemize}
  \end{block}
\end{frame}




\begin{frame}[fragile]{{\em exit\/} und {\em \_exit\/}}{}

\begin{block}{Exit-Handler}
\begin{itemize}
\item Jeder Prozess kann mit {\em atexit(f)\/} eine Funktion {\em f\/}
   als {\bf exit-Handler} registrieren
\item Bei Terminierung mit {\em exit\/} wird dann {\em f\/} aufgerufen
\item Verwendung: "`Aufräumaktionen"' aller Art, z.B. temporäre Datei löschen 
\item \_exit terminiert den Prozess {\bf ohne} Aufruf von exit-Handlern 
\end{itemize}
\end{block}

\begin{block}{Wann \_exit statt exit?}
\footnotesize
\begin{verbatim}
  switch (pid = fork()){
  case -1: ...
  case  0:
           execvp( ... );
           // exec gescheitert
           perror("exec error");
           _exit(1);
  ...
\end{verbatim}
\small
\begin{blue}
Was passiert hier bei Aufruf von exit, wenn ein exit-Handler registriert
ist, der temporäre Dateien löscht?
\end{blue}

\end{block}

\end{frame}



\begin{frame}[fragile]{waitpid - Status Kindprozess abrufen}{}

\begin{block}{Statusinformationen}
\begin{itemize}
\item Kind durch ein Signal terminiert: Signalnummer
\item Kind durch {\em exit\/} terminiert: exit-Argument
\end{itemize}
\end{block}

\begin{block}{Warte-Szenarien}
\begin{itemize}
\item Bei waitpid-Aufruf ist Kind schon terminiert: Kein Warten
\item Bei waitpid-Aufruf ist Kind noch aktiv: Warten, bis Kind terminiert
\item waitpid-Aufruf mit Option {\tt WNOHANG}: Kein Warten
\end{itemize}
\end{block}

\begin{block}{Mehrere Kindprozesse}
\begin{itemize}
\item waitpid(15,...) warten auf das Kind mit PID 15
\item waitpid(-1,...) wartet auf irgendein Kind, Returnwert: Kind-PID
\item weitere Möglichkeiten, siehe Manual
\end{itemize}

\end{block}


\end{frame}







\begin{frame}[fragile]{waitpid: Makros zur Statusanalyse}{}
\begin{block}{Beispiel-Code: Programm starten und Ende abwarten}
\footnotesize
\begin{verbatim}
  #include <sys/types.h>
  #include <sys/wait.h>

  ...

  int  kindstatus;

  switch (pid = fork()){
  case -1: ...
  case  0:
           execvp( ... );
           // exec gescheitert
           perror("exec error");
           _exit(1);
  }

  waitpid(pid, &status, 0);

  if(WIFEXITED(status))
     printf("Kind terminierte mit exit(%d)\n", WEXITSTATUS(status));
  else if(WIFSIGNALED(status))
     printf("Kind terminierte durch Signal %d\n", WTERMSIG(status));
  
\end{verbatim}
\end{block}

\end{frame}


\end{document}








